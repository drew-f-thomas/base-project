---
description: Zustand state management best practices and patterns
globs: src/state/**/*.ts,src/**/*Store.ts
alwaysApply: false
---

# Zustand Best Practices

## Store Access Patterns

### ✅ Use Selector Pattern (Recommended)

Always use selector functions to access specific state properties:

```typescript
// ✅ Good - Only subscribes to specific state changes
const isAuthenticated = useUserStore(state => state.isAuthenticated)
const user = useUserStore(state => state.user)
```

### ❌ Avoid Destructuring Entire Store

Never destructure the entire store as it causes unnecessary re-renders:

```typescript
// ❌ Bad - Subscribes to ALL state changes
const { user, isAuthenticated } = useUserStore()
```

## Multiple State Properties

### Use `shallow` for Multiple Properties

When accessing multiple state properties, use the `shallow` comparison:

```typescript
import { shallow } from 'zustand/shallow'

const { user, isAuthenticated } = useUserStore(
  state => ({
    user: state.user,
    isAuthenticated: state.isAuthenticated,
  }),
  shallow
)
```

## Store Structure

### Security Considerations

**Never store sensitive data** (tokens, keys, passwords) in Zustand stores:

```typescript
// ❌ Bad - Storing sensitive data in Zustand
type UserStore = {
  authToken: string // Never store tokens in Zustand
  apiKey: string // Never store keys in Zustand
  password: string // Never store passwords in Zustand
}

// ✅ Good - Use expo-secure-store for sensitive data
import * as SecureStore from 'expo-secure-store'

// Store sensitive data securely
await SecureStore.setItemAsync('authToken', token)
const token = await SecureStore.getItemAsync('authToken')

// Store only non-sensitive state in Zustand
type UserState = {
  user: User | null
  isAuthenticated: boolean
  setUser: (u: User | null) => void
  logout: () => void
}
```

### TypeScript Store Definition

Always define proper TypeScript types for your stores:

```typescript
type UserState = {
  // State properties
  user: User | null
  isAuthenticated: boolean

  // Actions
  setUser: (u: User | null) => void
  logout: () => void
}
```

### Action Implementation

Use proper state updates with functional updates:

```typescript
export const useUserStore = create<UserState>(set => ({
  user: null,
  isAuthenticated: false,

  // ✅ Good - Functional update
  setUser: (u: User | null) => set({ user: u, isAuthenticated: u !== null }),

  // ✅ Good - Logout action
  logout: () => set({ user: null, isAuthenticated: false }),
}))
```

## File Organization

### Store Location

Place stores in the `src/state/` directory following the pattern:

- `src/state/userStore.ts` - User-related state
- `src/state/appStore.ts` - App-wide state
- `src/state/featureStore.ts` - Feature-specific state

### Import Pattern

Use consistent import patterns:

```typescript
import { useUserStore } from '@/src/state/userStore'
```

## Performance Considerations

### Minimize Re-renders

- Always use selectors for single properties
- Use `shallow` for multiple properties
- Avoid accessing the entire store object

### Store Splitting

For large applications, consider splitting stores by domain:

- User authentication store
- UI state store
- Feature-specific stores

## Testing

### Store Testing

Test stores independently of React components:

```typescript
import { useUserStore } from '@/src/state/userStore'

// Test store actions
const s = useUserStore.getState()
s.setUser({
  id: '1',
  email: 'a@b.com',
  userName: 'John',
  createdAt: '',
  updatedAt: '',
})
expect(useUserStore.getState().isAuthenticated).toBe(true)
```

## Common Patterns

### Computed Values

Use selectors for computed values:

```typescript
const isUserReady = useUserStore(
  state => state.isAuthenticated && state.user !== null
)
```

### Conditional Rendering

Use selectors for conditional logic:

```typescript
const isAuthenticated = useUserStore((state) => state.isAuthenticated);

if (!isAuthenticated) {
  return <Redirect href="/login" />;
}
```

## Migration from Other State Managers

### From Redux

- Replace `useSelector` with Zustand selectors
- Replace `useDispatch` with direct action calls
- Remove Redux boilerplate (reducers, actions, etc.)

### From Context API

- Replace `useContext` with Zustand hooks
- Remove Context providers
- Simplify state access patterns
