---

globs: *.ts,*.tsx
description: TypeScript usage in an Expo React Native app — config, patterns, and conventions
---

---

# TypeScript in Expo React Native

## Project Config (tsconfig)

- Extend Expo’s base config and keep `strict: true`
- Preserve `expo-env.d.ts` and `.expo` includes
- Use `@/*` alias for app-local imports only

## Components & Props

- Prefer **function declarations** over expressions
- Avoid `React.FC`; declare explicit `Props` types
- Type `children` as `React.ReactNode` only when needed

```tsx
type UserCardProps = {
  name: string
  avatarUrl?: string
  children?: React.ReactNode
}

export function UserCard({ name, avatarUrl, children }: UserCardProps) {
  return avatarUrl ? <Image source={{ uri: avatarUrl }} /> : null
}
```

- For wrappers, derive props from RN primitives

```tsx
type PressableTextProps = React.ComponentPropsWithoutRef<typeof Pressable> & {
  text: string
}

export function PressableText({ text, ...rest }: PressableTextProps) {
  return (
    <Pressable {...rest}>
      <Text>{text}</Text>
    </Pressable>
  )
}
```

## State & Types

- No `any`. Use precise unions and `unknown` + narrowing
- Use descriptive generic names and `Array<T>` syntax

```tsx
type AuthUser = { id: string; email: string }

const [user, setUser] = React.useState<AuthUser | null>(null)
const [queue, setQueue] = React.useState<Array<string>>([])
```

- Prefer `as const` and `satisfies` to keep literals narrow

```ts
const theme = {
  spacing: { sm: 8, md: 12, lg: 16 },
} as const satisfies {
  spacing: Record<'sm' | 'md' | 'lg', number>
}
```

## Type Narrowing & Exhaustiveness

- Use explicit guards and exhaustive switches for discriminated unions

```ts
type LoadState =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'error'; message: string }
  | { status: 'success'; data: Array<string> }

function isLoaded(
  s: LoadState
): s is Extract<LoadState, { status: 'success' }> {
  return s.status === 'success'
}
```

## Routing (Expo Router)

- Use **typed routes** and absolute `href` paths
- Type search params with the route’s module path

```tsx
import { Link, useLocalSearchParams } from 'expo-router'

export function GoToUser() {
  return <Link href="/user/123" />
}

export default function UserScreen() {
  const { id } = useLocalSearchParams<'app/user/[id].tsx'>()
  return <Text>{id}</Text>
}
```

## Styles & RN APIs

- Let `StyleSheet.create` infer types
- Use typed callbacks for style props

```ts
const pressableStyle: React.ComponentProps<typeof Pressable>['style'] = ({
  pressed,
}) => [styles.base, pressed ? styles.pressed : null]
```

- Prefer literal unions for tokens

```ts
type SpacingKey = 'sm' | 'md' | 'lg'
const spacing: Record<SpacingKey, number> = { sm: 8, md: 12, lg: 16 }
```

## Modules & Imports

- Use the `@/src/*` alias for local modules

```ts
import { apiGet } from '@/src/lib/api/client'
import { useTheme } from '@/src/design-system/hooks/useTheme'
```

- Don't override Expo/Metro resolution without a clear reason

## Error Boundaries & Strictness

- Keep `"strict": true`
- Consider `noUncheckedIndexedAccess` and `exactOptionalPropertyTypes` for libs/utilities (opt-in only if ergonomics remain good)

## Environment Variables

- **Don't read `process.env` directly** in app code
- Always use `loadEnv()` from `@/src/config/env` for type-safe environment access

```ts
// ✅ Good - Use loadEnv()
import { loadEnv } from '@/src/config/env'

const { EXPO_PUBLIC_API_URL } = loadEnv()

// ❌ Bad - Direct process.env access
const apiUrl = process.env.EXPO_PUBLIC_API_URL
```

## Interop & Boundaries

- Avoid `as` casts except at trust boundaries (native modules, JSON)
- **Runtime validation with Zod is mandatory** for API responses using the `api()` wrapper
- Prefer runtime validation for external data

```ts
// ✅ Good - Zod validation with apiGet helper
import { apiGet } from '@/src/lib/api/client'
import { z } from 'zod'

const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
})

type User = z.infer<typeof UserSchema>

// API call with automatic validation
const user = await apiGet('/users/123', UserSchema)

// ❌ Bad - No validation
const user = await fetch('/api/users/123').then(r => r.json())
```

```ts
type ApiResponse<TData> =
  | {
      ok: true
      data: TData
    }
  | {
      ok: false
      error: string
    }
```

## Testing (TS)

- Write tests in TS
- Don’t export internal types solely for tests
- Use type-level assertions (e.g., `expectTypeOf`) in utility packages when needed

## Conventions

- Descriptive type names (`UserProfile`, `ApiResponse<TData>`)
- `Array<T>` over `T[]`
- Prefer `cond ? <X /> : null` over `cond && <X />`
- Avoid `enum` and `namespace`; prefer union literals and objects
- **Prefer named exports** (matches repo) and avoid default exports for types
- Keep public exports named (avoid default for types)

```ts
// ✅ Good - Named exports
export interface User {
  id: string
  name: string
}

export type UserRole = 'admin' | 'user'

// ❌ Bad - Default exports for types
export default interface User {
  id: string
  name: string
}
```
